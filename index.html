<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Frog Jumper ‚Äì Main (Landscape iPhone)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0d1321; color: #e6e6e6; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; touch-action: none; }
    #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr auto; }
    header { padding: calc(10px + env(safe-area-inset-top)) 14px 10px 14px; display: flex; align-items: center; gap: 12px; background: #11182a; border-bottom: 1px solid #1c2742; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; letter-spacing: .2px; color: #b7d6ff; }
    header .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: #1a2440; color: #a5c1ff; border: 1px solid #23315b; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; background: #0a121e; }
    #stage { position: relative; height: calc(100svh - var(--hf, 0px)); }
    footer { display: flex; gap: 16px; justify-content: space-between; align-items: center; padding: 8px 12px calc(8px + env(safe-area-inset-bottom)) 12px; background: #11182a; border-top: 1px solid #1c2742; font-size: 12px; }
    .hud { position: absolute; left: 12px; top: calc(56px + env(safe-area-inset-top)); background: rgba(0,0,0,.35); padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,.08); font-size: 14px; }
    .hud div { line-height: 1.2; }
    .btn { cursor: pointer; user-select: none; padding: 12px 16px; border-radius: 12px; border: 1px solid #32406a; background: #16213a; color: #cfe1ff; font-weight: 700; letter-spacing: .2px; font-size: 16px; }
    .btn:hover { filter: brightness(1.05); }
    .center { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; }
    .card { pointer-events: auto; width: min(94vw, 520px); background: #0f172a; border: 1px solid #1f2a4d; border-radius: 16px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,.4); text-align:center; }
    .title { font-size: clamp(22px, 5vw, 28px); margin: 4px 0 12px; color: #b7d6ff; font-weight: 800; letter-spacing: .5px; }
    .subtitle { opacity: .85; margin: 6px 0 16px; font-size: 14px; }
    .menu-stack { display: grid; gap: 12px; place-items: center; margin-top: 6px; }
    .row { display:flex; gap:12px; justify-content:center; margin-top:12px; flex-wrap: wrap; }
    .ghost { opacity: .7; }
    .list { text-align:left; background: #0b1224; border: 1px solid #1c2742; padding: 10px 12px; border-radius: 12px; max-height: 280px; overflow:auto; }
    .list h3 { margin: 0 0 8px; color: #a5c1ff; font-size: 14px; }
    .list ol { margin: 0; padding-left: 20px; }
    [hidden]{ display:none !important; }
    .asset-status { position:absolute; right:12px; top: calc(56px + env(safe-area-inset-top)); padding:6px 8px; font-size:12px; border-radius:10px; border:1px solid #2a3b68; background:#0f1a32; color:#9fc2ff; }
    .asset-status.error { color:#ff9f9f; border-color:#603333; background:#2a0f14; }
    .rotate { position:absolute; inset:0; display:grid; place-items:center; background: rgba(10, 16, 28, 0.85); backdrop-filter: blur(4px); color:#cfe1ff; font-weight:700; letter-spacing:.3px; }
    .rotate .box{ text-align:center; padding:24px; border-radius:16px; border:1px solid #23315b; background:#0f172a; box-shadow:0 10px 30px rgba(0,0,0,.4); max-width: 80vw; }
    .rotate .title{ font-size:20px; margin-bottom:8px; color:#b7d6ff; }
    .rotate .hint{ font-size:14px; opacity:.85; }
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <h1>üê∏ Frog Jumper</h1>
      <span class="pill">Drag to Aim ‚Ä¢ Release to Jump</span>
    </header>
    <div id="stage">
      <canvas id="game"></canvas>
      <div class="hud" id="hud"><div>Score: <span id="score">0</span></div><div>Best: <span id="best">0</span></div></div>
      <div class="asset-status" id="assetStatus">Loading art‚Ä¶</div>
      <div class="rotate" id="rotateOverlay" hidden>
        <div class="box">
          <div class="title">Rotate your phone</div>
          <div class="hint">This game plays in <b>landscape</b>. Turn your device sideways.</div>
        </div>
      </div>
      <div class="center" id="overlay"><div class="card" id="overlayCard"></div></div>
    </div>
    <footer>
      <div>Tip: Pull farther for a stronger jump. Angle the drag up/down to change trajectory. Land on platforms to keep going.</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button class="btn" id="howSmall">How to Play</button>
        <button class="btn" id="restartSmall">Restart (R)</button>
      </div>
    </footer>
  </div>

  <script>
  // === External assets (GitHub RAW). Repo/branch must be public ===
  const ASSETS = {
    background: 'https://raw.githubusercontent.com/Exclamation34/TestRepository/Background/Swampy_Background2.png',
    frog: {
      frames: [
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_1.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_2.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_3.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_4.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_5.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_6.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_7.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_8.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_9.png',
        'https://raw.githubusercontent.com/Exclamation34/TestRepository/main/Frog%20Jump_10.png'
      ],
      fps: 14
    }
  };

  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    // Force a first-time sizing before anything renders so the canvas does not cover the footer
    // and the start camera/platforms use the correct height.
    try { resizeInternal(); } catch {}

    // ---------- Resize (debounced) + iOS viewport quirks ----------
    let DPR=1, resizeRAF=0; const viewW=()=>Math.max(1, canvas.width/DPR); const viewH=()=>Math.max(1, canvas.height/DPR);
    function resizeInternal(){
      resizeRAF=0;
      const header = document.querySelector('header');
      const footer = document.querySelector('footer');
      const headerH = Math.ceil(header?.getBoundingClientRect().height || 0);
      const footerH = Math.ceil(footer?.getBoundingClientRect().height || 0);
      // expose to CSS so #stage can use 100dvh - (header+footer)
      document.documentElement.style.setProperty('--hf', `${headerH + footerH}px`);
      const parent = document.getElementById('stage') || canvas.parentElement || document.body;
      const r = parent.getBoundingClientRect();
      const w = Math.max(1, Math.floor(r.width));
      const h = Math.max(1, Math.floor(r.height));
      const next = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      if (w !== canvas.width / DPR || h !== canvas.height / DPR || next !== DPR) {
        DPR = next;
        canvas.width = Math.floor(w * DPR);
        canvas.height = Math.floor(h * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      }
    }
    const scheduleResize = () => { if (!resizeRAF) resizeRAF = requestAnimationFrame(resizeInternal); };
    new ResizeObserver(scheduleResize).observe(canvas.parentElement||canvas); window.addEventListener('resize',scheduleResize);
    if (window.visualViewport){
      visualViewport.addEventListener('resize', scheduleResize);
      visualViewport.addEventListener('scroll', scheduleResize);
    }
    // Prevent accidental zooming/scrolling gestures inside the app
    document.addEventListener('gesturestart', (e)=>{ e.preventDefault(); }, {passive:false});
    let lastTouchEnd=0; document.addEventListener('touchend', (e)=>{ const now=Date.now(); if (now-lastTouchEnd<300) e.preventDefault(); lastTouchEnd=now; }, {passive:false});
    document.addEventListener('touchmove', (e)=>{ if (e.scale !== undefined && e.scale !== 1) e.preventDefault(); }, {passive:false});

    // Orientation helpers
    const rotateOverlay = () => document.getElementById('rotateOverlay');
    const isLandscape = () => viewW() >= viewH();
    function updateRotateUI(){ const el=rotateOverlay(); if(!el) return; el.hidden = isLandscape(); }

    // ---------- Utils ----------
    const rand=(a,b)=>a+Math.random()*(b-a); const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

    // ---------- Game constants ----------
    const State={ MENU:'MENU', PLAY:'PLAY', OVER:'OVER', SCORES:'SCORES' }; let state=State.MENU;
    // If player taps Play while the phone is still in portrait, defer starting
    let pendingStart=false;
    const G=1800, MAX_POWER=1400, POWER_SCALE=4, FROG_RADIUS=24; // slightly larger for art
    const FROG_SINK = 3; // small visual sink so frog sits on the grass cap
    const PLATFORM_WIDTH_RANGE=[120,180], PLATFORM_GAP_RANGE=[140,280], PLATFORM_Y_DRIFT=140, WORLD_FLOOR=10000;

    // ---------- Entities ----------
    let camX=0; const input={down:false,sx:0,sy:0,x:0,y:0};
    const frog={x:0,y:0,vx:0,vy:0,onGround:false};
    let platforms=[]; let score=0; let lastLandedX=0;

    // ---------- High scores ----------
    const HS_KEY='frog_highscores_v1';
    const getHS=()=>{ try{return JSON.parse(localStorage.getItem(HS_KEY)||'[]');}catch{return[];} };
    const setHS=a=>localStorage.setItem(HS_KEY,JSON.stringify(a));
    const bestScore=()=>{ const a=getHS(); return a.length?a[0].score:0; };
    function submitHS(v){ const a=getHS(); a.push({score:v,ts:Date.now()}); a.sort((x,y)=>y.score-x.score); setHS(a.slice(0,10)); }

    // ---------- Overlay helpers ----------
    const overlay=document.getElementById('overlay');
    const overlayCard=document.getElementById('overlayCard');
    const statusEl=document.getElementById('assetStatus');
    function setStatus(msg, error){ statusEl.textContent = msg; statusEl.classList.toggle('error', !!error); }

    function showMenu(){
      pendingStart=false;
      state=State.MENU; overlay.hidden=false; overlayCard.innerHTML=`
      <div class="title">üê∏ Frog Jumper</div>
      <div class="subtitle">Drag to aim ¬∑ Release to jump</div>
      <div class="menu-stack">
        <button class="btn" id="playBtn">Play</button>
        <button class="btn" id="scoresBtn">High Scores</button>
        <button class="btn" id="howBtn">How to Play</button>
      </div>`;
      document.getElementById('playBtn').onclick=startGame;
      document.getElementById('scoresBtn').onclick=showScores;
      document.getElementById('howBtn').onclick=showHow;
      document.getElementById('best').textContent=bestScore();
    }
    function showScores(){
      const a=getHS();
      const items=a.length?a.map(h=>`<li><b>${h.score}</b> <span class=ghost>‚Äî ${new Date(h.ts).toLocaleDateString()}</span></li>`).join(''):'<li class=ghost>No scores yet</li>';
      overlay.hidden=false; overlayCard.innerHTML=`
      <div class=title>High Scores</div>
      <div class=list><h3>Top ${Math.min(10,Math.max(1,a.length))}</h3><ol>${items}</ol></div>
      <div class=row><button class=btn id=backBtn>Main Menu</button><button class=btn id=playBtn>Play</button></div>`;
      document.getElementById('backBtn').onclick=showMenu;
      document.getElementById('playBtn').onclick=startGame;
    }
    function showHow(){
      overlay.hidden=false; overlayCard.innerHTML=`
      <div class=title>How to Play</div>
      <div class=subtitle style="text-align:left">Hold the frog ¬∑ Drag to aim & power ¬∑ Release to jump. Score increases only when you <b>land</b>.</div>
      <div class=row><button class=btn id=backBtn>Back</button></div>`;
      document.getElementById('backBtn').onclick=showMenu;
    }
    function showOver(){
      state=State.OVER; submitHS(score); overlay.hidden=false; overlayCard.innerHTML=`
      <div class=title>Game Over</div>
      <div class=subtitle>Your score: <b>${score}</b><br/>Best: <b>${bestScore()}</b></div>
      <div class=row><button class=btn id=tryBtn>Try Again</button><button class=btn id=menuBtn>Main Menu</button></div>`;
      document.getElementById('tryBtn').onclick=startGame;
      document.getElementById('menuBtn').onclick=showMenu;
    }

    document.getElementById('howSmall').onclick=showHow;
    document.getElementById('restartSmall').onclick=()=>{ if(state===State.PLAY) resetGame(); };

    // ---------- Reset / start ----------
    function resetGame(){
      // Make sure we have the latest viewport (iOS can lag a frame when rotating/showing bars)
      try { resizeInternal(); } catch {}
      camX=0; score=0; platforms=[]; frog.vx=frog.vy=0; frog.onGround=true; 
      const H=Math.max(240, viewH());
      // Standard band for ongoing platforms
      const midY = Math.floor(H * 0.68);
      const minY = Math.max(160, midY - 120);
      const maxY = Math.min(H - 120, midY + 120);
      // Spawn the very first platform LOWER so the frog is clearly visible before first jump
      const startY = Math.floor(H * 0.86);
      const START_W = 320; const startPlat={x:-START_W/2,y:clamp(startY,minY,maxY),w:START_W,h:16};
      platforms.push(startPlat);
      frog.x=0; frog.y=startPlat.y - FROG_RADIUS + FROG_SINK; lastLandedX=frog.x;
      camX = frog.x - lookAhead();
      let px=startPlat.x+startPlat.w+rand(120,180), py=startPlat.y;
      for(let i=0;i<16;i++){
        py=clamp(py+rand(-PLATFORM_Y_DRIFT,PLATFORM_Y_DRIFT),minY,maxY);
        const w=rand(...PLATFORM_WIDTH_RANGE);
        platforms.push({x:px,y:py,w,h:14});
        px+=w+rand(...PLATFORM_GAP_RANGE);
      }
      overlay.hidden=true; document.getElementById('score').textContent='0'; document.getElementById('best').textContent=bestScore();
    }
    function startGame(){
      // If not landscape yet, defer start until orientation changes
      if(!isLandscape()){
        pendingStart=true; overlay.hidden=true; updateRotateUI();
        return;
      }
      resetGame(); state=State.PLAY;
    }

    // ---------- Camera ----------
    function camBias(){ return 120; }
    function lookAhead(){ return 160; }
    const worldToScreen=(x,y)=>[x - camX + viewW()/2 - camBias(), y];

    // ---------- Platforms ----------
    function ensurePlatformsAhead(){
      const rightEdge=camX+viewW()+400; let maxX=-Infinity; for(const p of platforms) maxX=Math.max(maxX,p.x+p.w);
      while(maxX<rightEdge){
        const last=platforms[platforms.length-1];
        const w=rand(...PLATFORM_WIDTH_RANGE);
        // Recompute the vertical band each time in case the viewport changed (iOS chrome show/hide)
        const H=viewH();
        const midY = Math.floor(H * 0.68);
        const minY = Math.max(160, midY - 120);
        const maxY = Math.min(H - 120, midY + 120);
        const y=clamp(last.y+rand(-PLATFORM_Y_DRIFT,PLATFORM_Y_DRIFT), minY, maxY);
        const x=last.x+last.w+rand(...PLATFORM_GAP_RANGE);
        platforms.push({x,y,w,h:14});
        maxX=x+w;
      }
      const leftCull=camX-viewW()-300; if(platforms.length>40) platforms=platforms.filter(p=>p.x+p.w>leftCull);
    }

    // ---------- Physics ----------
    function integrate(dt){
      if(state!==State.PLAY) return;
      if(!frog.onGround){
        frog.vy+=G*dt; frog.x+=frog.vx*dt; frog.y+=frog.vy*dt;
        // advance background parallax only while airborne
        bgParallaxX += frog.vx * dt * 0.25;
      }
      const targetCam=Math.max(camX, frog.x - lookAhead()); camX+=(targetCam-camX)*0.08;

      // Side-wall collisions (pillars are solid columns)
      if(!frog.onGround){
        const r = FROG_RADIUS;
        for(const p of platforms){
          const rx = p.x, ry = p.y, rw = p.w, rh = WORLD_FLOOR;
          if(frog.x + r < rx-2 || frog.x - r > rx+rw+2) continue;
          if(frog.y + r < ry-2) continue;
          const nx = Math.max(rx, Math.min(frog.x, rx+rw));
          const ny = Math.max(ry, Math.min(frog.y, ry+rh));
          const dx = frog.x - nx, dy = frog.y - ny; const dist2 = dx*dx + dy*dy;
          if(dist2 < r*r){
            const dist = Math.max(0.0001, Math.sqrt(dist2));
            const px = (dx/dist) * (r - dist);
            const py = (dy/dist) * (r - dist);
            frog.x += px; frog.y += py;
            frog.vx *= 0.2; // damp horizontal
            frog.vy = Math.max(frog.vy*0.2, 50); // drop
          }
        }
      }

      // Top landing
      if(frog.vy>0){
        const fb=frog.y+FROG_RADIUS; const ftPrev=fb - frog.vy*dt;
        for(const p of platforms){
          const top=p.y; const withinX=frog.x>p.x-FROG_RADIUS && frog.x<p.x+p.w+FROG_RADIUS; const crossing=ftPrev<=top && fb>=top;
          if(withinX && crossing){
            frog.y=top - FROG_RADIUS + FROG_SINK; frog.vy=0; frog.onGround=true;
            const dx=Math.max(0, frog.x - lastLandedX); score += Math.floor(dx / 10); lastLandedX=frog.x; document.getElementById('score').textContent=String(score);
            landHoldUntil = performance.now() + 160;
            break;
          }
        }
      }
      if(frog.y - FROG_RADIUS > WORLD_FLOOR || frog.y - FROG_RADIUS > viewH()+200){ showOver(); }
      ensurePlatformsAhead();
    }

    // ---------- Assets: load background + frog frames ----------
    const frames=[]; let framesLoaded=false; let landHoldUntil=0; const FPS = ASSETS.frog?.fps || 14;
    let bgImg=null, bgReady=false; let bgParallaxX=0; // accumulates only while airborne

    function loadImage(url){ return new Promise(res=>{ const img=new Image(); img.crossOrigin='anonymous'; img.onload=()=>res(img); img.onerror=()=>{ console.warn('Failed to load',url); res(null); }; img.src=url; }); }
    function loadFrames(){
      const list=(ASSETS.frog?.frames||[]);
      if(!list.length){ framesLoaded=false; return Promise.resolve(); }
      let ok=0,fail=0; setStatus('Loading frog art‚Ä¶');
      return Promise.all(list.map(src=>loadImage(src).then(img=>{ if(img) ok++; else fail++; setStatus(`Frog ${ok}/${list.length}${fail?` (failed ${fail})`:''}`); return img; }))).then(imgs=>{
        imgs.filter(Boolean).forEach(i=>frames.push(i));
        framesLoaded=frames.length>0; setStatus(framesLoaded? `Frog art ready (${frames.length})` : 'No frog frames', !framesLoaded);
      });
    }
    function loadBackground(){
      if(!ASSETS.background){ bgReady=false; return Promise.resolve(); }
      setStatus('Loading background‚Ä¶');
      return loadImage(ASSETS.background).then(img=>{ bgImg=img; bgReady=!!img; setStatus(bgReady? 'Background ready' : 'Background failed', !bgReady); });
    }

    // Map vertical speed -> non-looping frame index (0 idle; 1..9 midair)
    function airborneFrameIndex(vy){
      const k=MAX_POWER*0.8;
      if(vy<0){ const t=Math.max(0,Math.min(1,(-vy)/k)); return 1+Math.floor(t*4); }
      else { const t=Math.max(0,Math.min(1,(vy)/k)); return 5+Math.floor(t*4); }
    }

    // ---------- Rendering ----------
    function drawBackground(dt){
      const w=viewW(), h=viewH();
      if(bgReady && bgImg){
        const scale = h / bgImg.height; const tileW = Math.max(1, Math.floor(bgImg.width * scale));
        const offset = ((-bgParallaxX) % tileW + tileW) % tileW;
        const startX = -tileW + offset;
        for(let x=startX; x<w+tileW; x+=tileW){ ctx.drawImage(bgImg, x, 0, tileW, h); }
      } else {
        const g=ctx.createLinearGradient(0,0,0,h); g.addColorStop(0,'#0f1e33'); g.addColorStop(1,'#0a121e'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
      }
    }

    function drawPlatforms(){
      const h=viewH();
      for(const p of platforms){
        const [sx,sy]=worldToScreen(p.x,p.y);
        ctx.fillStyle='#6b4423'; ctx.fillRect(Math.round(sx), Math.round(sy), Math.round(p.w), Math.round(h - sy));
        ctx.globalAlpha=0.18; for(let i=1;i<=3;i++){ ctx.fillRect(Math.round(sx + (i*p.w/4)), Math.round(sy)+6, 2, Math.round(h-sy)); } ctx.globalAlpha=1;
        ctx.fillStyle='#397b2e'; ctx.fillRect(Math.round(sx)-1, Math.round(sy)-6, Math.round(p.w)+2, 8);
        ctx.fillStyle='#2b5e23'; ctx.fillRect(Math.round(sx), Math.round(sy), Math.round(p.w), 14);
      }
    }

    function drawFrog(){
      const [fx,fy]=worldToScreen(frog.x,frog.y);
      // Shadow only when over a platform
      let shadow = null; let closestDy = Infinity;
      for(const p of platforms){
        if(frog.x >= p.x-6 && frog.x <= p.x+p.w+6){
          const dyTop = p.y - (frog.y + FROG_RADIUS);
          if(dyTop >= -2 && dyTop < closestDy && dyTop < 180){ closestDy = dyTop; shadow = p; }
        }
      }
      if(shadow){
        const [sx,sy] = worldToScreen(frog.x, shadow.y);
        const alpha = 0.35 * (1 - Math.min(1, closestDy/180));
        const rx = FROG_RADIUS * (1 + Math.min(0.6, closestDy/120));
        ctx.globalAlpha = alpha; ctx.beginPath(); ctx.ellipse(sx, sy+6, rx*1.1, 6, 0, 0, Math.PI*2); ctx.fillStyle='#000'; ctx.fill(); ctx.globalAlpha=1;
      }

      // Frog sprite
      let img=null;
      if(framesLoaded && frames.length){
        if (frog.onGround){
          if(performance.now() < landHoldUntil) img=frames[Math.min(9,frames.length-1)];
          else img=frames[0];
        } else {
          const idx=Math.max(1, Math.min(frames.length-1, airborneFrameIndex(frog.vy)));
          img=frames[idx];
        }
      }
      if(img){
        const scale=(FROG_RADIUS*2)/Math.max(img.width,img.height); const dw=img.width*scale, dh=img.height*scale;
        ctx.imageSmoothingEnabled=false; ctx.drawImage(img, fx-dw/2, fy-dh/2, dw, dh); ctx.imageSmoothingEnabled=true;
      } else {
        ctx.beginPath(); ctx.arc(fx,fy,FROG_RADIUS,0,Math.PI*2); ctx.fillStyle='#5bd17f'; ctx.fill();
        ctx.beginPath(); ctx.arc(fx, fy+4, FROG_RADIUS*0.7, 0, Math.PI*2); ctx.fillStyle='#b6f5c8'; ctx.fill();
      }
    }

    function drawAim(){
      if(state!==State.PLAY || !input.down) return;
      const [fx,fy]=worldToScreen(frog.x,frog.y);
      const dx=input.x-input.sx, dy=input.y-input.sy; const len=Math.hypot(dx,dy), cl=clamp(len,0,MAX_POWER/POWER_SCALE);
      const ax=fx+(input.sx-input.x), ay=fy+(input.sy-input.y);
      ctx.lineWidth=3; ctx.strokeStyle='#a5c1ff'; ctx.fillStyle='#a5c1ff'; ctx.globalAlpha=.9;
      ctx.beginPath(); ctx.moveTo(fx,fy); ctx.lineTo(ax,ay); ctx.stroke();
      const ang=Math.atan2(ay-fy,ax-fx), ah=10;
      ctx.beginPath(); ctx.moveTo(ax,ay);
      ctx.lineTo(ax-ah*Math.cos(ang-.4), ay-ah*Math.sin(ang-.4));
      ctx.lineTo(ax-ah*Math.cos(ang+.4), ay-ah*Math.sin(ang+.4));
      ctx.closePath(); ctx.fill();
      ctx.globalAlpha=1; ctx.fillStyle='#22325f'; ctx.fillRect(fx-60,fy-52,120,10);
      ctx.fillStyle='#7fb0ff'; ctx.fillRect(fx-60,fy-52,120*(cl/(MAX_POWER/POWER_SCALE)),10);
      ctx.strokeStyle='#3e5aa1'; ctx.strokeRect(fx-60,fy-52,120,10);
    }

    // ---------- Input ----------
    const pointerInFrog=(px,py)=>{ const [fx,fy]=worldToScreen(frog.x,frog.y); return Math.hypot(px-fx,py-fy) <= FROG_RADIUS+10; };
    function onDown(px,py){ if(!isLandscape()) return; if(state!==State.PLAY) return; if(!frog.onGround) return; if(!pointerInFrog(px,py)) return; input.down=true; input.sx=px; input.sy=py; input.x=px; input.y=py; }
    function onMove(px,py){ if(!input.down) return; input.x=px; input.y=py; }
    function onUp(){ if(!input.down) return; const dx=input.x-input.sx, dy=input.y-input.sy; const vx=clamp(-dx*POWER_SCALE,-MAX_POWER,MAX_POWER), vy=clamp(-dy*POWER_SCALE,-MAX_POWER,MAX_POWER); if(Math.hypot(dx,dy)>6){ frog.vx=vx; frog.vy=vy; frog.onGround=false; } input.down=false; }
    canvas.addEventListener('mousedown', e=>onDown(e.offsetX,e.offsetY)); canvas.addEventListener('mousemove', e=>onMove(e.offsetX,e.offsetY)); window.addEventListener('mouseup', onUp);
    canvas.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; const r=canvas.getBoundingClientRect(); onDown(t.clientX-r.left, t.clientY-r.top); e.preventDefault(); }, {passive:false});
    canvas.addEventListener('touchmove', e=>{ const t=e.changedTouches[0]; const r=canvas.getBoundingClientRect(); onMove(t.clientX-r.left, t.clientY-r.top); e.preventDefault(); }, {passive:false});
    canvas.addEventListener('touchend', e=>{ onUp(); e.preventDefault(); }, {passive:false});

    window.addEventListener('keydown', e=>{ const k=e.key.toLowerCase(); if(k==='r' && state===State.PLAY) resetGame(); if(k==='escape') showMenu(); });

    // ---------- Loop ----------
    let last=performance.now();
    // Also resume deferred start on any viewport change
    window.addEventListener('orientationchange', ()=>{ if(pendingStart && isLandscape()){ resetGame(); state=State.PLAY; pendingStart=false; } });
    visualViewport?.addEventListener('resize', ()=>{ if(pendingStart && isLandscape()){ resetGame(); state=State.PLAY; pendingStart=false; } });
    function frame(t){
      const dt=Math.min((t-last)/1000,1/30); last=t;
      // If user hit Play in portrait, start as soon as we become landscape
      if(pendingStart && isLandscape()){
        resetGame(); state=State.PLAY; pendingStart=false;
      }
      // Block gameplay in portrait; show rotate overlay
      if(!isLandscape()){
        updateRotateUI();
        ctx.clearRect(0,0,viewW(),viewH());
        drawBackground(0);
        requestAnimationFrame(frame);
        return;
      }
      updateRotateUI();
      integrate(dt);
      ctx.clearRect(0,0,viewW(),viewH());
      drawBackground(dt); drawPlatforms(); drawFrog(); drawAim();
      requestAnimationFrame(frame);
    }

    // ---------- Simple runtime sanity tests (console) ----------
    function runSanityTests(){
      console.groupCollapsed('Sanity Tests');
      try{
        console.assert(typeof scheduleResize==='function','scheduleResize exists');
        console.assert(typeof airborneFrameIndex==='function','airborneFrameIndex exists');
        [-1400,-800,-1,0,1,800,1400].forEach(vy=>{
          const idx=airborneFrameIndex(vy);
          console.assert(idx>=1 && idx<=9, 'airborneFrameIndex in 1..9 for vy='+vy);
        });
        console.assert(Array.isArray(ASSETS.frog.frames) && ASSETS.frog.frames.length===10,'10 frog frames configured');
        try{ drawBackground(0.016); console.log('drawBackground() OK'); } catch(e){ console.error('drawBackground threw',e); }
      } finally { console.groupEnd(); }
    }

    // ---------- Boot ----------
    scheduleResize();
    window.addEventListener('load', resizeInternal);
    Promise.all([loadBackground(), loadFrames()]).then(()=>{ runSanityTests(); showMenu(); requestAnimationFrame(frame); });
  })();
  </script>
</body>
</html>
